# Claude Code Switch (CCS) 技术方案

## 调研总结

### Windows/macOS环境变量永久化方案

#### Windows环境变量永久化

**1. setx命令** (推荐方案)
```powershell
# 用户级别
setx ANTHROPIC_BASE_URL "https://api.anthropic.com"
setx ANTHROPIC_AUTH_TOKEN "sk-xxx"

# 系统级别 (需管理员权限)
setx ANTHROPIC_BASE_URL "https://api.anthropic.com" /m
setx ANTHROPIC_AUTH_TOKEN "sk-xxx" /m
```

**特点**:
- 直接写入Windows注册表
- 永久生效，重启后依然存在
- 需要重启终端/命令行窗口才能在新会话中生效
- 系统级别需要管理员权限

**2. PowerShell .NET方法**
```powershell
# 用户级别
[Environment]::SetEnvironmentVariable("ANTHROPIC_BASE_URL", "https://api.anthropic.com", "User")

# 系统级别 (需管理员权限)
[Environment]::SetEnvironmentVariable("ANTHROPIC_BASE_URL", "https://api.anthropic.com", "Machine")
```

**3. 注册表存储位置**
- 用户变量: `HKEY_CURRENT_USER\Environment`
- 系统变量: `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment`

#### macOS环境变量永久化

**1. Shell配置文件** (推荐方案)
```bash
# Zsh (macOS Catalina+)
echo 'export ANTHROPIC_BASE_URL="https://api.anthropic.com"' >> ~/.zshenv
echo 'export ANTHROPIC_AUTH_TOKEN="sk-xxx"' >> ~/.zshenv

# Bash (pre-Catalina)  
echo 'export ANTHROPIC_BASE_URL="https://api.anthropic.com"' >> ~/.bash_profile
```

**配置文件优先级**:
- `~/.zshenv` - 所有Shell调用时都会加载 ⭐推荐
- `~/.zshrc` - 交互式Shell启动时加载
- `~/.zprofile` - 登录Shell时加载

**2. launchctl系统级别**
```bash
# 系统级别环境变量 (不推荐，重启后失效)
launchctl setenv ANTHROPIC_BASE_URL "https://api.anthropic.com"
launchctl setenv ANTHROPIC_AUTH_TOKEN "sk-xxx"
```

**特点**:
- 可以让所有GUI应用程序都能访问
- 但在新版macOS中重启后会失效
- 不影响SSH会话

#### 跨平台环境变量管理策略

**1. 平台检测**
```javascript
const os = require('os');
const platform = os.platform();

if (platform === 'win32') {
  // Windows: 使用setx命令
} else if (platform === 'darwin') {
  // macOS: 使用shell配置文件
} else {
  // Linux: 使用shell配置文件
}
```

**2. Node.js跨平台工具参考**
- **cross-env**: 临时环境变量设置的标准工具
- **dotenv**: 配置文件加载环境变量

### 第三次调研：Claude-Code-Toolkit 实际项目分析

#### 项目架构分析

**配置存储方案** (参考Claude-Code-Toolkit)
- **配置目录**: `~/.claude/` (Windows: `%USERPROFILE%\.claude\`)
- **提供商文件**: `providers.json` - 存储多厂商配置
- **Claude配置**: `.claude.json` - Claude Code核心配置

**providers.json 结构**:
```json
{
  "provider_name": {
    "base_url": "https://api.example.com/anthropic/",
    "api_key": "your_api_key_here"
  }
}
```

#### 环境变量持久化实现验证

**Windows 实现** (已验证有效):
```powershell
# 永久设置用户级环境变量
[System.Environment]::SetEnvironmentVariable("ANTHROPIC_BASE_URL", $baseUrl, "User")
[System.Environment]::SetEnvironmentVariable("ANTHROPIC_API_KEY", $apiKey, "User")

# 立即在当前会话生效
$env:ANTHROPIC_BASE_URL = $baseUrl
$env:ANTHROPIC_API_KEY = $apiKey
```

**macOS/Linux 实现** (已验证有效):
```bash
# 智能检测Shell配置文件
detect_shell_config_file() {
  case "$SHELL" in
    *zsh*) echo "$HOME/.zshrc" ;;
    *bash*) echo "$HOME/.bashrc" 或 "$HOME/.bash_profile" ;;
    *fish*) echo "$HOME/.config/fish/config.fish" ;;
    *) echo "$HOME/.profile" ;;
  esac
}

# 更新环境变量
sed -i'.bak' '/^export ANTHROPIC_BASE_URL=/d' "$config_file"
sed -i'.bak' '/^export ANTHROPIC_API_KEY=/d' "$config_file"
echo "export ANTHROPIC_BASE_URL=\"$base_url\"" >> "$config_file"
echo "export ANTHROPIC_API_KEY=\"$api_key\"" >> "$config_file"
```

## 最终技术方案（基于实际项目优化）

### 1. 整体架构设计

**配置存储方案** (采用Claude-Code-Toolkit的成熟方案)
```
配置文件位置:
- Windows: %USERPROFILE%\.claude\providers.json
- macOS/Linux: ~/.claude/providers.json

配置文件结构:
{
  "anthropic": {
    "base_url": "",
    "api_key": "sk-xxx"
  },
  "moonshot": {
    "base_url": "https://api.moonshot.cn/anthropic/",
    "api_key": "sk-xxx"
  },
  "openrouter": {
    "base_url": "https://openrouter.ai/api/v1",
    "api_key": "sk-xxx"
  }
}
```

### 2. 核心功能实现方案

#### 命令行接口设计
```bash
ccs list                    # 列出所有配置的厂商
ccs show [name]            # 显示指定厂商详细信息
ccs add [name]             # 添加新厂商配置
ccs use [name]             # 切换到指定厂商
ccs remove [name]          # 删除厂商配置
ccs current                # 显示当前活跃厂商
ccs --help                 # 显示帮助信息
```

#### 环境变量管理策略 

**Windows实现** (使用.NET Framework方法)
```javascript
const { execSync } = require('child_process');

class WindowsEnvManager {
  // 使用PowerShell .NET方法实现永久设置
  setEnvVar(name, value) {
    const psScript = `
      [System.Environment]::SetEnvironmentVariable("${name}", "${value}", "User");
      $env:${name} = "${value}";
    `;
    
    try {
      execSync(`powershell -Command "${psScript}"`, { stdio: 'pipe' });
      return true;
    } catch (error) {
      console.error('Failed to set Windows environment variable:', error.message);
      return false;
    }
  }
  
  removeEnvVar(name) {
    const psScript = `
      [System.Environment]::SetEnvironmentVariable("${name}", $null, "User");
      $env:${name} = $null;
    `;
    
    try {
      execSync(`powershell -Command "${psScript}"`, { stdio: 'pipe' });
      return true;
    } catch (error) {
      return false;
    }
  }
}
```

**macOS/Linux实现** (使用Shell配置文件方法)
```javascript
const fs = require('fs');
const os = require('os');
const path = require('path');
const { execSync } = require('child_process');

class UnixEnvManager {
  // 智能检测Shell配置文件
  detectShellConfigFile() {
    const shell = process.env.SHELL || '';
    const homeDir = os.homedir();
    
    // 检测顺序：当前shell -> 常用配置文件
    const configFiles = [];
    
    if (shell.includes('zsh')) {
      configFiles.push(path.join(homeDir, '.zshrc'));
      configFiles.push(path.join(homeDir, '.zshenv'));
    } else if (shell.includes('bash')) {
      configFiles.push(path.join(homeDir, '.bashrc'));
      configFiles.push(path.join(homeDir, '.bash_profile'));
    } else if (shell.includes('fish')) {
      configFiles.push(path.join(homeDir, '.config/fish/config.fish'));
    }
    
    // 默认配置文件
    configFiles.push(path.join(homeDir, '.profile'));
    
    // 返回第一个存在的配置文件，如果都不存在则返回.profile
    for (const file of configFiles) {
      if (fs.existsSync(file)) {
        return file;
      }
    }
    
    return path.join(homeDir, '.profile');
  }
  
  setEnvVar(name, value) {
    const configFile = this.detectShellConfigFile();
    
    try {
      // 确保配置文件存在
      if (!fs.existsSync(configFile)) {
        const dir = path.dirname(configFile);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }
        fs.writeFileSync(configFile, '');
      }
      
      // 读取现有内容
      let content = fs.readFileSync(configFile, 'utf8');
      
      // 移除现有的同名变量（支持export和set语法）
      const exportRegex = new RegExp(`^export ${name}=.*$`, 'gm');
      const setRegex = new RegExp(`^set -gx ${name}.*$`, 'gm');
      content = content.replace(exportRegex, '').replace(setRegex, '');
      
      // 添加新的环境变量
      const isfish = configFile.includes('config.fish');
      const envLine = isfish 
        ? `set -gx ${name} "${value}"` 
        : `export ${name}="${value}"`;
      
      content = content.trim() + '\n' + envLine + '\n';
      
      // 写回文件
      fs.writeFileSync(configFile, content);
      
      return true;
    } catch (error) {
      console.error('Failed to set Unix environment variable:', error.message);
      return false;
    }
  }
  
  removeEnvVar(name) {
    const configFile = this.detectShellConfigFile();
    
    try {
      if (!fs.existsSync(configFile)) {
        return true; // 文件不存在，认为移除成功
      }
      
      let content = fs.readFileSync(configFile, 'utf8');
      
      // 移除相关的环境变量设置
      const exportRegex = new RegExp(`^export ${name}=.*$`, 'gm');
      const setRegex = new RegExp(`^set -gx ${name}.*$`, 'gm');
      content = content.replace(exportRegex, '').replace(setRegex, '');
      
      fs.writeFileSync(configFile, content);
      return true;
    } catch (error) {
      return false;
    }
  }
}
```

### 3. 配置管理实现 (基于JSON文件存储)

**配置管理器**
```javascript
const fs = require('fs');
const path = require('path');
const os = require('os');

class ConfigManager {
  constructor() {
    this.configDir = path.join(os.homedir(), '.claude');
    this.providersFile = path.join(this.configDir, 'providers.json');
    this.ensureConfigDir();
  }
  
  // 确保配置目录存在
  ensureConfigDir() {
    if (!fs.existsSync(this.configDir)) {
      fs.mkdirSync(this.configDir, { recursive: true });
    }
  }
  
  // 确保providers.json文件存在
  ensureProvidersFile() {
    if (!fs.existsSync(this.providersFile)) {
      fs.writeFileSync(this.providersFile, '{}', 'utf8');
    }
  }
  
  // 读取providers配置
  loadProviders() {
    this.ensureProvidersFile();
    try {
      const content = fs.readFileSync(this.providersFile, 'utf8');
      return JSON.parse(content);
    } catch (error) {
      console.warn('providers.json文件损坏，重新创建...');
      fs.writeFileSync(this.providersFile, '{}', 'utf8');
      return {};
    }
  }
  
  // 保存providers配置
  saveProviders(providers) {
    try {
      const content = JSON.stringify(providers, null, 2);
      fs.writeFileSync(this.providersFile, content, 'utf8');
      return true;
    } catch (error) {
      console.error('保存配置失败:', error.message);
      return false;
    }
  }
  
  // 添加provider
  addProvider(name, baseUrl, apiKey) {
    const providers = this.loadProviders();
    
    providers[name] = {
      base_url: baseUrl,
      api_key: apiKey
    };
    
    return this.saveProviders(providers);
  }
  
  // 获取provider详情
  getProvider(name) {
    const providers = this.loadProviders();
    
    // 处理内置Anthropic provider
    if (name === 'Anthropic') {
      return {
        base_url: '',
        api_key: ''
      };
    }
    
    if (!providers[name]) {
      throw new Error(`Provider '${name}' not found`);
    }
    
    return providers[name];
  }
  
  // 列出所有providers
  listProviders() {
    const providers = this.loadProviders();
    const result = ['Anthropic: (使用官方API默认设置)'];
    
    Object.keys(providers).forEach(key => {
      result.push(`${key}: ${providers[key].base_url}`);
    });
    
    return result;
  }
  
  // 删除provider
  removeProvider(name) {
    if (name === 'Anthropic') {
      throw new Error('无法删除内置的Anthropic provider');
    }
    
    const providers = this.loadProviders();
    
    if (!providers[name]) {
      throw new Error(`Provider '${name}' not found`);
    }
    
    delete providers[name];
    return this.saveProviders(providers);
  }
}
```

### 4. 安全性设计 (简化版 - 参考实际项目)

**基础安全措施**
```javascript
class SecurityManager {
  // 设置配置文件权限 (Unix系统)
  setConfigPermissions(filePath) {
    if (process.platform !== 'win32') {
      try {
        fs.chmodSync(filePath, 0o600); // 仅所有者可读写
      } catch (error) {
        console.warn('无法设置文件权限:', error.message);
      }
    }
  }
  
  // 验证URL格式
  validateUrl(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
  
  // 基础的输入验证
  validateInput(input, type = 'string') {
    if (typeof input !== 'string' || input.trim().length === 0) {
      return false;
    }
    
    if (type === 'provider_name') {
      // Provider名称只允许字母、数字、空格、横线、下划线
      return /^[a-zA-Z0-9\s\-_]+$/.test(input.trim());
    }
    
    if (type === 'api_key') {
      // API密钥基本格式验证
      return input.trim().length >= 10;
    }
    
    return true;
  }
}
```

### 5. 用户体验设计 (参考Claude-Code-Toolkit)

**彩色CLI输出**
```javascript
const chalk = require('chalk');

class UIManager {
  success(message) {
    console.log(chalk.green('✓'), message);
  }
  
  error(message) {
    console.log(chalk.red('✗'), message);
  }
  
  info(message) {
    console.log(chalk.blue('ℹ'), message);
  }
  
  warning(message) {
    console.log(chalk.yellow('⚠'), message);
  }
  
  // 显示厂商列表
  displayProviders(providers, active) {
    console.log(chalk.bold('\nAvailable providers:'));
    
    Object.keys(providers).forEach(key => {
      const provider = providers[key];
      const indicator = key === active ? chalk.green('*') : ' ';
      const status = key === active ? chalk.green('(active)') : '';
      
      console.log(`${indicator} ${chalk.cyan(key)} - ${provider.name} ${status}`);
      if (provider.baseUrl) {
        console.log(`    ${chalk.gray(provider.baseUrl)}`);
      }
    });
  }
}
```

**交互式配置**
```javascript
const inquirer = require('inquirer');

class ConfigManager {
  async addProvider(name) {
    const questions = [
      {
        type: 'input',
        name: 'displayName',
        message: 'Provider display name:',
        default: name
      },
      {
        type: 'input',
        name: 'baseUrl',
        message: 'Base URL (Anthropic compatible):',
        validate: (input) => {
          try {
            new URL(input);
            return true;
          } catch {
            return 'Please enter a valid URL';
          }
        }
      },
      {
        type: 'list',
        name: 'authType',
        message: 'Authentication type:',
        choices: ['api_key', 'auth_token'],
        default: 'api_key'
      },
      {
        type: 'password',
        name: 'token',
        message: 'API Key/Token:',
        mask: '*'
      }
    ];
    
    return await inquirer.prompt(questions);
  }
  
  async confirmSwitch(fromProvider, toProvider) {
    const { confirm } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'confirm',
        message: `Switch from "${fromProvider}" to "${toProvider}"?`,
        default: true
      }
    ]);
    
    return confirm;
  }
}
```

### 6. 核心功能实现

**主要命令实现**
```javascript
class CCS {
  constructor() {
    this.configManager = new ConfigManager();
    this.envManager = process.platform === 'win32' 
      ? new WindowsEnvManager() 
      : new UnixEnvManager();
    this.ui = new UIManager();
    this.security = new SecurityManager();
  }
  
  // ccs list - 列出所有providers
  async list() {
    try {
      const providers = this.configManager.listProviders();
      this.ui.info('Available providers:');
      providers.forEach(provider => {
        console.log(`  ${provider}`);
      });
    } catch (error) {
      this.ui.error(`列出providers失败: ${error.message}`);
    }
  }
  
  // ccs add - 添加新provider
  async add(name, baseUrl, apiKey) {
    try {
      // 输入验证
      if (!this.security.validateInput(name, 'provider_name')) {
        throw new Error('Provider名称格式无效');
      }
      
      if (!this.security.validateUrl(baseUrl)) {
        throw new Error('Base URL格式无效');
      }
      
      if (!this.security.validateInput(apiKey, 'api_key')) {
        throw new Error('API Key格式无效');
      }
      
      // 添加provider
      if (this.configManager.addProvider(name, baseUrl, apiKey)) {
        this.ui.success(`Provider '${name}' 添加成功`);
      } else {
        throw new Error('保存配置失败');
      }
    } catch (error) {
      this.ui.error(`添加provider失败: ${error.message}`);
    }
  }
  
  // ccs use - 切换provider
  async use(name) {
    try {
      const provider = this.configManager.getProvider(name);
      
      // 设置环境变量
      const success = provider.base_url 
        ? this.envManager.setEnvVar('ANTHROPIC_BASE_URL', provider.base_url) &&
          this.envManager.setEnvVar('ANTHROPIC_API_KEY', provider.api_key)
        : this.envManager.removeEnvVar('ANTHROPIC_BASE_URL') &&
          this.envManager.setEnvVar('ANTHROPIC_API_KEY', provider.api_key);
      
      if (success) {
        this.ui.success(`已切换到provider: ${name}`);
        this.ui.info('请重启终端或执行 source ~/.bashrc (或相应的shell配置文件) 使更改生效');
      } else {
        throw new Error('设置环境变量失败');
      }
    } catch (error) {
      this.ui.error(`切换provider失败: ${error.message}`);
    }
  }
  
  // ccs current - 显示当前provider
  async current() {
    try {
      const baseUrl = process.env.ANTHROPIC_BASE_URL;
      const apiKey = process.env.ANTHROPIC_API_KEY;
      
      if (!baseUrl && !apiKey) {
        this.ui.info('当前未设置任何provider');
        return;
      }
      
      if (!baseUrl) {
        this.ui.info('Current provider: Anthropic (使用官方API默认设置)');
      } else {
        // 尝试通过base_url匹配provider名称
        const providers = this.configManager.loadProviders();
        const providerName = Object.keys(providers).find(key => 
          providers[key].base_url === baseUrl
        ) || 'Unknown';
        
        this.ui.info(`Current provider: ${providerName} (${baseUrl})`);
      }
    } catch (error) {
      this.ui.error(`获取当前provider失败: ${error.message}`);
    }
  }
}
```

### 7. 错误处理和验证

**配置验证**
```javascript
class ValidationManager {
  validateConfig(config) {
    const errors = [];
    
    if (!config.active || !config.providers[config.active]) {
      errors.push('Invalid active provider');
    }
    
    Object.keys(config.providers).forEach(key => {
      const provider = config.providers[key];
      
      if (!provider.baseUrl) {
        errors.push(`Provider "${key}" missing baseUrl`);
      }
      
      if (!provider.token) {
        errors.push(`Provider "${key}" missing token`);
      }
      
      try {
        new URL(provider.baseUrl);
      } catch {
        errors.push(`Provider "${key}" has invalid baseUrl`);
      }
    });
    
    return errors;
  }
  
  async testConnection(provider) {
    try {
      const response = await fetch(provider.baseUrl + '/v1/messages', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${provider.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'claude-3-haiku-20240307',
          max_tokens: 1,
          messages: [{ role: 'user', content: 'test' }]
        })
      });
      
      return response.status !== 401 && response.status !== 403;
    } catch (error) {
      return false;
    }
  }
}
```

### 8. 部署和分发策略

**打包方案**
- 使用 `pkg` 或 `nexe` 打包成独立可执行文件
- 支持 Windows (.exe), macOS, Linux 三个平台
- 提供 npm 包分发选项

**安装方式**
```bash
# npm 全局安装
npm install -g claude-code-switch

# 或直接下载可执行文件
curl -L https://github.com/user/ccs/releases/latest/download/ccs-macos -o /usr/local/bin/ccs
chmod +x /usr/local/bin/ccs
```

### 9. 测试策略

**单元测试覆盖**
- 配置文件读写测试
- 环境变量设置测试
- 加密解密功能测试
- 跨平台兼容性测试

**集成测试**
- 完整的厂商添加、切换、删除流程测试
- 不同操作系统环境下的功能测试
- Claude Code 集成测试

### 10. 实施路线图

**Phase 1: 核心功能实现** (基于Claude-Code-Toolkit验证的方案)
- ✅ Windows环境变量永久化 (使用.NET Framework方法)
- ✅ macOS/Linux环境变量永久化 (使用Shell配置文件)
- ✅ JSON配置文件管理
- ✅ 基础的增删查改功能

**Phase 2: 用户体验优化**
- 彩色CLI输出和交互式提示
- 详细的错误处理和验证
- 配置文件权限管理

**Phase 3: 高级功能**
- 配置导入导出
- 连接测试和验证
- Shell自动补全

### 11. 与Claude-Code-Toolkit的差异化

**我们的优势**:
1. **专注性**: 专门针对Claude Code厂商切换，功能更聚焦
2. **简洁性**: 更简洁的配置文件结构和命令接口
3. **扩展性**: 更好的架构设计，便于后续功能扩展
4. **用户体验**: 更友好的错误提示和交互设计

**继承的优秀实践**:
1. ✅ 经过验证的环境变量持久化方案
2. ✅ 成熟的配置文件管理机制
3. ✅ 跨平台Shell兼容性处理
4. ✅ 智能的Shell类型检测

### 12. 未来扩展规划

**V1.0 MVP功能**
- 基础的增删查改功能
- Windows/macOS 环境变量永久化
- 简单的CLI交互

**V1.1 增强功能**
- 配置文件导入导出
- 连接测试和验证
- 更好的错误提示


这套技术方案综合了两次调研的成果，提供了完整、安全、跨平台的Claude Code厂商切换解决方案。